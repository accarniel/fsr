[{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://accarniel.github.io/fsr/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"Copyright (C) 2021-2022 Anderson Chaves Carniel, Felippe Galdino Silva, Juliana Strieder Philippsen The fsr package is developed to handle fuzzy spatial data in R.  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. fsr Copyright (C) 2021-2022 Anderson Chaves Carniel, Felippe Galdino Silva, Juliana Philippsen This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://accarniel.github.io/fsr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Anderson Carniel. Research team head, author, maintainer. Felippe Galdino. Research team member, author. Juliana Philippsen. Research team member, author. Markus Schneider. Research team head.","code":""},{"path":"https://accarniel.github.io/fsr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson Chaves Carniel, Felippe Galdino, Juliana Strieder Philippsen, Markus Schneider. 2021. Handling Fuzzy Spatial Data R Using fsr Package. Proceedings 29th International Conference Advances Geographic Information Systems (SIGSPATIAL '21), 526–535. DOI:https://doi.org/10.1145/3474717.3484255","code":"@InProceedings{fsr21SIGSPATIAL,   title = {Handling Fuzzy Spatial Data in R using the {fsr} Package},   author = {Anderson C. Carniel and Felippe Galdino and Juliana S. Philippsen and Markus Schneider},   booktitle = {ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems},   year = {2021},   pages = {526-535},   doi = {10.1145/3474717.3484255}, }"},{"path":[]},{"path":"https://accarniel.github.io/fsr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Handling Fuzzy Spatial Data","text":"Many spatial objects (.e., geographical objects) reality may inexact locations, vague boundaries, /blurred interiors, hence adequately represented well-known (crisp) spatial objects (e.g., objects available spatial libraries like GEOS GDAL). Fuzzy set theory fuzzy logic powerful approaches deal spatial fuzziness. Unfortunately, spatial fuzziness far found way spatial data science projects due lack complete implementations software packages can handle fuzzy spatial objects. Motivated lack support, fsr package following advantages: implementation fuzzy spatial data types, operations, predicates Spatial Plateau Algebra (SPA). offers construction fuzzy spatial objects spatial plateau objects real spatial datasets. families functions permit users conduct exploratory (spatial) data analysis issuing geometric operations topological predicates fuzzy spatial objects. provides methods designing fuzzy spatial inference models discover new findings fuzzy spatial objects. deploys algorithms determine evaluate subset points really contributes finding final approximated answer user’s query window inference.","code":""},{"path":"https://accarniel.github.io/fsr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Handling Fuzzy Spatial Data","text":"cite package publications use: Carniel, . C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data R Using fsr Package. Proceedings 29th International Conference Advances Geographic Information Systems (ACM SIGSPATIAL 2021), pp. 526-535, 2021.","code":""},{"path":"https://accarniel.github.io/fsr/index.html","id":"installing","dir":"","previous_headings":"","what":"Installing","title":"Handling Fuzzy Spatial Data","text":"Install released version fsr CRAN : Install development version GitHub :","code":"install.packages(\"fsr\") # install.packages(\"devtools\") library(devtools) install_github(\"accarniel/fsr\")"},{"path":"https://accarniel.github.io/fsr/index.html","id":"contributing-and-contact","dir":"","previous_headings":"","what":"Contributing and Contact","title":"Handling Fuzzy Spatial Data","text":"project welcomes contributions three different perspectives. can contribute fsr making Issues Pull Requests GitHub Repository. Alternatively, contact Anderson Carniel sending email accarniel@ufscar.br. Pull Request email sent, Anderson Carniel check soon possible.","code":""},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":null,"dir":"Reference","previous_headings":"","what":"The PWKT of a spatial plateau object — PWKT","title":"The PWKT of a spatial plateau object — PWKT","text":"function gives Plateau Well-Known Text (PWKT) representation pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The PWKT of a spatial plateau object — PWKT","text":"","code":"spa_pwkt(pgo)  # S3 method for pgeometry format(x, ...)  # S4 method for pgeometry show(object)  # S4 method for pgeometry as.character(x, ...)"},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The PWKT of a spatial plateau object — PWKT","text":"pgo pgeometry object type. x pgeometry object type. ... <dynamic-dots> Unused. object pgeometry object type.","code":""},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The PWKT of a spatial plateau object — PWKT","text":"character value textual representation given pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The PWKT of a spatial plateau object — PWKT","text":"gives textual representation pgeometry object, combining Well-Known Text (WKT) representation crisp vector geometry objects formal definitions tree spatial plateau data types. (.e. PLATEAUPOINT, PLATEAULINE, PLATEAUREGION).","code":""},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The PWKT of a spatial plateau object — PWKT","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/PWKT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The PWKT of a spatial plateau object — PWKT","text":"","code":"library(sf)  # For a `PLATEAUPOINT` object. pts1 <- rbind(c(1, 2), c(3, 2)) comp1 <- component_from_sfg(st_multipoint(pts1), 0.2)  comp2 <- component_from_sfg(st_point(c(1, 5)), 0.8)    ppoint <- create_pgeometry(list(comp1, comp2), \"PLATEAUPOINT\")  spa_pwkt(ppoint) #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.2), (POINT (1 5), 0.8))\"  # For a `PLATEAULINE` object.  lpts1 <- rbind(c(0, 0), c(1, 1)) lpts2 <- rbind(c(1, 1), c(1.2, 1.9), c(2, 1)) lpts3 <- rbind(c(2, 1), c(1.5, 0.5))  comp4 <- component_from_sfg(st_linestring(lpts1), 0.4) comp5 <- component_from_sfg(st_linestring(lpts2), 1) comp6 <- component_from_sfg(st_linestring(lpts3), 0.7)  pline <- create_pgeometry(list(comp4, comp5, comp6), \"PLATEAULINE\")  spa_pwkt(pline) #> [1] \"PLATEAULINE ((LINESTRING (0 0, 1 1), 0.4), (LINESTRING (2 1, 1.5 0.5), 0.7), (LINESTRING (1 1, 1.2 1.9, 2 1), 1))\"  # For a `PLATEAUREGION` object.  p1 <- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)) p2 <- rbind(c(1,1), c(1,2), c(2,2), c(1,1)) pol1 <-st_polygon(list(p1,p2))  comp1 <- component_from_sfg(pol1, 0.2)  pregion <- create_pgeometry(list(comp1), \"PLATEAUREGION\")  spa_pwkt(pregion) #> [1] \"PLATEAUREGION ((POLYGON ((0 0, 1 0, 3 2, 2 4, 1 4, 0 0), (1 1, 1 2, 2 2, 1 1)), 0.2))\""},{"path":"https://accarniel.github.io/fsr/reference/as_tibble.pgeometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","title":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","text":"can convert pgeometry object tabular data, tibble data.frame object, components pgeometry object compose rows table.","code":""},{"path":"https://accarniel.github.io/fsr/reference/as_tibble.pgeometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","text":"","code":"# S3 method for pgeometry as.data.frame(x, ...)  # S3 method for pgeometry as_tibble(x, ...)"},{"path":"https://accarniel.github.io/fsr/reference/as_tibble.pgeometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","text":"x pgeometry object. ... <dynamic-dots> Unused.","code":""},{"path":"https://accarniel.github.io/fsr/reference/as_tibble.pgeometry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","text":"tibble object size n x 2 n number components pgeometry object two columns format (md, geometry).","code":""},{"path":"https://accarniel.github.io/fsr/reference/as_tibble.pgeometry.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","text":"function interface S3 generic as_tibble. , turns pgeometry object tibble, data frame class tbl_df. allows us get internal components pgeometry object (.e., spatial features objects membership degrees) data frame two separate columns - called md (membership degree) geometry (sfc object). component pgeometry object, as_tibble gets md geometry values allocates row new created tibble, separated columns. Therefore, row tibble represents component original pgeometry object. also possible call S3 method .data.frame convert pgeometry object tabular data.","code":""},{"path":"https://accarniel.github.io/fsr/reference/as_tibble.pgeometry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converting a pgeometry object into tabular data — as_tibble.pgeometry","text":"","code":"library(sf)  # Creating components for our plateau point object v1 <- rbind(c(1,2), c(3,4)) v2 <- rbind(c(1,4), c(2,3),c(4,4))  md1 <- 0.2 md2 <- 0.1 md3 <- 0.4 pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  comp1 <- component_from_sfg(st_multipoint(pts1), md1) comp2 <- component_from_sfg(st_multipoint(pts2), md2) comp3 <- component_from_sfg(st_multipoint(pts3), md3)  # Creating the plateau point object as a pgeometry object with 3 components  plateau_point <- create_pgeometry(list(comp1, comp2, comp3), \"PLATEAUPOINT\")  # Converting the pgeometry object into a tibble object plateau_point_tibble <- as_tibble(plateau_point)  plateau_point_tibble #> # A tibble: 3 × 2 #>      md              geometry #>   <dbl>          <MULTIPOINT> #> 1   0.1 ((1 1), (2 3), (2 1)) #> 2   0.2        ((1 2), (3 2)) #> 3   0.4        ((2 2), (3 3))"},{"path":"https://accarniel.github.io/fsr/reference/component-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An S4 Class for representing a component of a spatial plateau object — component-class","title":"An S4 Class for representing a component of a spatial plateau object — component-class","text":"S4 Class representing component spatial plateau object","code":""},{"path":"https://accarniel.github.io/fsr/reference/component-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"An S4 Class for representing a component of a spatial plateau object — component-class","text":"component object composed two attributes. first one crisp spatial object second one membership degree ]0, 1]  component.","code":""},{"path":"https://accarniel.github.io/fsr/reference/component-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"An S4 Class for representing a component of a spatial plateau object — component-class","text":"obj sfg object. md membership degree component.","code":""},{"path":"https://accarniel.github.io/fsr/reference/component-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"An S4 Class for representing a component of a spatial plateau object — component-class","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_empty_pgeometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Creation of an empty pgeometry object — create_empty_pgeometry","title":"Creation of an empty pgeometry object — create_empty_pgeometry","text":"function builds empty pgeometry object specific type.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_empty_pgeometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creation of an empty pgeometry object — create_empty_pgeometry","text":"","code":"create_empty_pgeometry(type)"},{"path":"https://accarniel.github.io/fsr/reference/create_empty_pgeometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creation of an empty pgeometry object — create_empty_pgeometry","text":"type character value indicating data type pgeometry object. can either \"PLATEAUPOINT\", \"PLATEAULINE\" \"PLATEAUREGION\".","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_empty_pgeometry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creation of an empty pgeometry object — create_empty_pgeometry","text":"pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_empty_pgeometry.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creation of an empty pgeometry object — create_empty_pgeometry","text":"create_empty_pgeometry creates new pgeometry object components. add new components object, use spa_add_component. components added object must type empty pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_empty_pgeometry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creation of an empty pgeometry object — create_empty_pgeometry","text":"","code":"# Creating an Empty Plateau Point object empty_plateau_point <- create_empty_pgeometry(\"PLATEAUPOINT\")  # Creating an Empty Plateau Line object empty_plateau_line <- create_empty_pgeometry(\"PLATEAULINE\")  # Creating an Empty Plateau Region object empty_plateau_region <- create_empty_pgeometry(\"PLATEAUREGION\")"},{"path":"https://accarniel.github.io/fsr/reference/create_pgeometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Creation of a pgeometry object with components — create_pgeometry","title":"Creation of a pgeometry object with components — create_pgeometry","text":"function creates pgeometry object data.frame list components.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_pgeometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creation of a pgeometry object with components — create_pgeometry","text":"","code":"create_pgeometry(components, type)"},{"path":"https://accarniel.github.io/fsr/reference/create_pgeometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creation of a pgeometry object with components — create_pgeometry","text":"components list component objects data.frame. type component must components. type character value indicates type desired pgeometry object. either \"PLATEAUPOINT\", \"PLATEAULINE\", \"PLATEAUREGION\". must compatible components given components parameter.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_pgeometry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creation of a pgeometry object with components — create_pgeometry","text":"pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_pgeometry.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creation of a pgeometry object with components — create_pgeometry","text":"create_pgeometry function creates pgeometry object given type. object built using either list component objects dataframe (tibble). dataframe given, must two columns: first one sfc object second one indicates membership degree respective object sfc column.","code":""},{"path":"https://accarniel.github.io/fsr/reference/create_pgeometry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creation of a pgeometry object with components — create_pgeometry","text":"","code":"library(sf) # Example 1 - Creating an `PLATEAUPOINT` object.  # Creating components for the plateau point object v1 <- rbind(c(1,2), c(3,4)) v2 <- rbind(c(1,4), c(2,3),c(4,4))  md1 <- 0.2 md2 <- 0.1 md3 <- 0.4 pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  comp1 <- component_from_sfg(st_multipoint(pts1), md1) comp2 <- component_from_sfg(st_multipoint(pts2), md2) comp3 <- component_from_sfg(st_multipoint(pts3), md3)  # Creating the plateau point object as a pgeometry object with 3 components  plateau_point_pgeom <- create_pgeometry(list(comp1, comp2, comp3), \"PLATEAUPOINT\")  # Example 2 - Creating an `PLATEAULINE` object.  lpts1 <- rbind(c(0, 0), c(1, 1)) lpts2 <- rbind(c(1, 1), c(1.2, 1.9), c(2, 1)) lpts3 <- rbind(c(2, 1), c(1.5, 0.5))  comp4 <- component_from_sfg(st_linestring(lpts1), 0.4) comp5 <- component_from_sfg(st_linestring(lpts2), 1) comp6 <- component_from_sfg(st_linestring(lpts3), 0.7)  plateau_line <- create_pgeometry(list(comp4, comp5, comp6), \"PLATEAULINE\")"},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_cs.html","id":null,"dir":"Reference","previous_headings":"","what":"Adding the consequent to an FSI model — fsi_add_cs","title":"Adding the consequent to an FSI model — fsi_add_cs","text":"function adds consequent fuzzy spatial inference (FSI) model. consists set membership functions labeled linguistic values.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_cs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adding the consequent to an FSI model — fsi_add_cs","text":"","code":"fsi_add_cs(fsi, lvar, lvals, mfs, bounds)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_cs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adding the consequent to an FSI model — fsi_add_cs","text":"fsi FSI model instantiated fsi_create function. lvar character value represents linguistic variable consequent. lvals character vector represents linguistic values linguistic variable consequent. mfs vector functions created genmf FuzzyR package. bounds numeric vector represents lower upper bounds consequent domain.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_cs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adding the consequent to an FSI model — fsi_add_cs","text":"FSI model populated consequent.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_cs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adding the consequent to an FSI model — fsi_add_cs","text":"linguistic value defined lvals parameter membership function defined mfs parameter. lvals character vector containing names linguistic values mfs vector containing corresponding membership functions. Thus, vectors defined two parameters must length. instance, first value lvals linguistic value first membership function mfs. bounds, lower upper values correspond first second parameter, respectively.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_cs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adding the consequent to an FSI model — fsi_add_cs","text":"","code":"library(FuzzyR)  # Create the fsi_model: fsi <- fsi_create(\"To visit or not to visit, that is the question\",                     default_conseq = genmf(\"trimf\", c(10, 30, 60)))  # Create the vector with the linguistic values of the linguistic variable \"visiting experience\": lvals_visiting_exp <- c(\"awful\", \"average\", \"great\")  # Define the membership function for each linguistic value: awful_mf <- genmf(\"trimf\", c(0, 0, 20)) average_mf <- genmf(\"trimf\", c(10, 30, 60)) great_mf <- genmf(\"trapmf\", c(40, 80, 100, 100))  # Add the consequent to the FSI model: fsi <- fsi_add_cs(fsi, \"visiting experience\", lvals_visiting_exp,                   c(awful_mf, average_mf, great_mf), c(0, 100))"},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_fsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Adding an antecedent to an FSI model — fsi_add_fsa","title":"Adding an antecedent to an FSI model — fsi_add_fsa","text":"function adds fuzzy spatial antecedent fuzzy spatial inference (FSI) model. fuzzy spatial antecedent corresponds layer fuzzy spatial objects describe different characteristics problem. antecedent linguistic variable fuzzy spatial objects linguistic values used part fuzzy rules.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_fsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adding an antecedent to an FSI model — fsi_add_fsa","text":"","code":"fsi_add_fsa(fsi, lvar, tbl)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_fsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adding an antecedent to an FSI model — fsi_add_fsa","text":"fsi FSI model instantiated fsi_create function. lvar character value represents linguistic variable antecedent. tbl tibble spatial plateau objects annotated linguistic values linguistic variable specified lvar parameter.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_fsa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adding an antecedent to an FSI model — fsi_add_fsa","text":"FSI model populated fuzzy spatial antecedent.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_fsa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adding an antecedent to an FSI model — fsi_add_fsa","text":"fuzzy spatial antecedent added fsi_add_fsa function composed linguistic variable corresponding pgeometry objects annotated linguistic values. format tbl parameter output function spa_creator, allowing user directly provides plateau region objects input designing FSI models.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_fsa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adding an antecedent to an FSI model — fsi_add_fsa","text":"","code":"library(FuzzyR) library(tibble)  # Create spatial plateau objects for the linguistic variable accomodation_price lvals_accom_price <- c(\"cut-rate\", \"affordable\", \"expensive\") cut_rate_mf <- genmf(\"trapmf\", c(0, 0, 10, 48)) affordable_mf <- genmf(\"trapmf\", c(10, 48, 80, 115)) expensive_mf <- genmf(\"trapmf\", c(80, 115, 10000, 10000))  # Example of dataset accom_price <- tibble(                       `longitude` = c(-74.0, -74.0, -74.0),                        `latitude` = c(40.8, 40.7, 40.7),                       `price` = c(150, 76, 60) )   accom_price_layer <- spa_creator(accom_price, classes = lvals_accom_price,                           mfs = c(cut_rate_mf, affordable_mf, expensive_mf))                           # Create the fsi_model: fsi <- fsi_create(\"To visit or not to visit, that is the question\",                    default_conseq = genmf(\"trimf\", c(10, 30, 60)))  # Add the fuzzy spatial antecedent to the fsi_model: fsi <- fsi_add_fsa(fsi, \"accommodation price\", accom_price_layer)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Adding fuzzy rules to an FSI model — fsi_add_rules","title":"Adding fuzzy rules to an FSI model — fsi_add_rules","text":"function adds fuzzy rules set fuzzy spatial inference (FSI) model. fuzzy rule must contain linguistic variables values employed added antecedent parts consequent.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adding fuzzy rules to an FSI model — fsi_add_rules","text":"","code":"fsi_add_rules(fsi, rules, weights = rep(1, length(rules)))"},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_rules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adding fuzzy rules to an FSI model — fsi_add_rules","text":"fsi FSI model instantiated function fsi_create. rules character vector containing rules defined user. follows specific format, detailed . weights numeric vector weight values rule. Default values 1.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_rules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adding fuzzy rules to an FSI model — fsi_add_rules","text":"FSI model populated fuzzy rules set.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adding fuzzy rules to an FSI model — fsi_add_rules","text":"definition fuzzy rule user-friendly since users can write using linguistic variables linguistic values previously defined added FSI model. fuzzy rule format B, called antecedent B consequent rule implies B.  , B statements combine fuzzy propositions using logical connectives like . fuzzy proposition format LVar LVal LVal linguistic value scope linguistic variable LVar. avoid possible contradictions keep mind following items specifying rules: order statements antecedent relevant; linguistic variable appear one time fuzzy rule;","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_add_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adding fuzzy rules to an FSI model — fsi_add_rules","text":"","code":"# Creating the FSI model from an example implemented with the visitation function: fsi <- visitation()  # Creating a vector of fuzzy rules;  ## note that we make use of the linguistic variables and linguistic values previously defined: rules <- c(   \"IF accommodation review is reasonable AND food safety is low    THEN visiting experience is awful\",  \"IF accommodation price is expensive AND accommodation review is reasonable     THEN visiting experience is awful\",  \"IF accommodation price is affordable AND accommodation review is good AND food safety is medium     THEN visiting experience is average\",  \"IF accommodation price is affordable AND accommodation review is excellent                                                                  AND food safety is high     THEN visiting experience is great\",  \"IF accommodation price is cut-rate AND accommodation review is excellent AND food safety is high     THEN visiting experience is great\")  # Adding these rules to the FSI model previously instantiated: fsi <- fsi_add_rules(fsi, rules)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Creation of an empty fuzzy spatial inference model — fsi_create","title":"Creation of an empty fuzzy spatial inference model — fsi_create","text":"function builds fuzzy spatial inference (FSI) model without elements data source component (.e., spatial plateau objects, fuzzy rules set, fuzzy sets).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creation of an empty fuzzy spatial inference model — fsi_create","text":"","code":"fsi_create(name, and_method = \"min\", or_method = \"max\",            imp_method = \"min\", agg_method = \"max\",             defuzz_method = \"centroid\", default_conseq = NULL)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creation of an empty fuzzy spatial inference model — fsi_create","text":"name character value specifies name FSI model. and_method character value defines operator name logical connective . Default value \"min\". or_method character value defines operator logical connective . Default value \"max\". imp_method character value defines operator implication operator. Default value \"min\". agg_method character value defines operator aggregation operator. Default value \"max\". defuzz_method character value determines defuzzification technique. Default value centroid technique. default_conseq parameter membership function generated function genmf FuzzyR package.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creation of an empty fuzzy spatial inference model — fsi_create","text":"empty named FSI model ready populated fuzzy rules representing antecedents consequent.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_create.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creation of an empty fuzzy spatial inference model — fsi_create","text":"FSI model created function fsi_create default parameter values implement model using Mamdani's method. possible values parameters and_method imp_method : \"min\", \"prod\". t-norms FuzzyR package also conceivable. possible value parameters or_method agg_method : \"max\". t-conorms FuzzyR package also conceivable. possible values parameter defuzz_method include defuzzification techniques FuzzyR package. parameter default_conseq defines default behavior FSI model fuzzy rule degree fulfillment greater 0 returned FSI model. creating empty FSI model, call functions fsi_add_fsa, fsi_add_cs, fsi_add_rules fulfill FSI model.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creation of an empty fuzzy spatial inference model — fsi_create","text":"","code":"library(FuzzyR) # Creating the FSI model fsi <- fsi_create(\"To visit or not to visit, that is the question\",                    default_conseq = genmf(\"trimf\", c(10, 30, 60)))"},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluating an FSI model for a given point location — fsi_eval","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"function executes reasoning process fuzzy spatial inference (FSI) model given point location (.e., sfg object type POINT).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"","code":"fsi_eval(fsi, point, ...)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"fsi FSI model built function fsi_create populated functions fsi_add_fsa, fsi_add_cs, fsi_add_rules. point sfg object geometry type point, created function st_point sf package. ... <dynamic-dots> Informs fsi_eval elements resulting fuzzy set discretized user want default configuration (see ). Default values: discret_by 0.5 discret_length NULL.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"numeric value belongs domain consequent (.e., specified fsi_add_cs) represents result reasoning process particular point location.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"function evaluates FSI model populated fuzzy spatial antecedent, consequent, fuzzy rules set specific point location. evaluation based algorithm specified FIFUS. default behavior function fsi_eval parameter ... consider discrete interval values increment 0.5 lower upper values consequent domain (.e., defined fsi_add_cs function parameter bounds). user can modify default behavior using one following two ways: define value parameter discret_by changing incremental value. define desired length sequence values domain consequent discret_length.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"Carniel, . C.; Schneider, M. Fuzzy inference fuzzy spatial objects (FIFUS) spatial decision support systems. Proceedings 2017 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluating an FSI model for a given point location — fsi_eval","text":"","code":"library(sf) # Creating the FSI model from an example implemented with the visitation function: fsi <- visitation()  # Creating a vector of fuzzy rules;  ## note that we make use of the linguistic variables and linguistic values previously defined: rules <- c(   \"IF accommodation review is reasonable AND food safety is low    THEN visiting experience is awful\",  \"IF accommodation price is expensive AND accommodation review is reasonable     THEN visiting experience is awful\",  \"IF accommodation price is affordable AND accommodation review is good AND food safety is medium     THEN visiting experience is average\",  \"IF accommodation price is affordable AND accommodation review is excellent                                                                  AND food safety is high     THEN visiting experience is great\",  \"IF accommodation price is cut-rate AND accommodation review is excellent AND food safety is high     THEN visiting experience is great\")  # Adding these rules to the FSI model previously instantiated: fsi <- fsi_add_rules(fsi, rules)  # Using the default configuration: res <- fsi_eval(fsi, st_point(c(-74.0, 40.7)))  # Change the default discretization by modifying the default step value: res <- fsi_eval(fsi, st_point(c(-74.0, 40.7)), discret_by=0.8)  # Change the default discretization by choosing the quantity of values  ## between the lower and upper values for the consequent domain: res <- fsi_eval(fsi, st_point(c(-74.0, 40.7)), discret_length=200)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_qw_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluating a query window inference — fsi_qw_eval","title":"Evaluating a query window inference — fsi_qw_eval","text":"function implements two approaches evaluating query window inference fuzzy spatial inference (FSI) model. Given query window (.e., rectangular object), returns set inferred points inside window satisfy specific condition (e.g., target linguistic value, maximum/minimum inferred values).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_qw_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluating a query window inference — fsi_qw_eval","text":"","code":"fsi_qw_eval(fsi, qw, approach = \"discretization\", ...)"},{"path":"https://accarniel.github.io/fsr/reference/fsi_qw_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluating a query window inference — fsi_qw_eval","text":"fsi FSI model built fsi_create function populated following functions fsi_add_fsa, fsi_add_cs, fsi_add_rules. qw sfg object storing query window supposed used input inference. axis-aligned rectangle represented simple polygon object 5 points (since last coordinate pair closes external ring rectangle). approach Defines approach employed perform query window inference: “discretization” “pso”. Default value `\"discretization\"`` ... <dynamic-dots> Different set parameters required depending chosen approach (see details ).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_qw_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluating a query window inference — fsi_qw_eval","text":"tibble format (points, inferred_values), points sfc object (.e., list sfg objects geometry type POINT) inferred_values inferred values domain consequent FSI model.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_qw_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluating a query window inference — fsi_qw_eval","text":"discretization approach, two additional parameters needed informed using three-dots parameter ...: target_lval: character value indicates target linguistic value linguistic variable consequent. k: numeric value defines number points captured query window evaluated function fsi_eval. square root integer value.   Alternatively, can inform number columns rows regular grid performed query window informing numeric values n_col n_row, respectively. Thus, parameters can given instead number k. pso approach, necessary set following parameters: : character value defines user's goal, can either maximize minimize inferred values. Thus, parameter can “max” “min”, respectively. default value “max”. max_depth: numeric value refers number times user wants split query window. default value equal 2. instance, max_depth = 2 results query window split four sub quadrants, particle swarm optimization (PSO) algorithm applied one search space. addition, PSO algorithm set parameters: maxit: numeric value defines maximum number iterations. Default value 50. population: numeric value defines number particles. Default value 10.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsi_qw_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluating a query window inference — fsi_qw_eval","text":"","code":"library(sf) # Creating the FSI model from an example implemented with the visitation function: fsi <- visitation()  # Creating a vector of fuzzy rules;  ## note that we make use of the linguistic variables and linguistic values previously defined: rules <- c(   \"IF accommodation review is reasonable AND food safety is low    THEN visiting experience is awful\",  \"IF accommodation price is expensive AND accommodation review is reasonable     THEN visiting experience is awful\",  \"IF accommodation price is affordable AND accommodation review is good AND food safety is medium     THEN visiting experience is average\",  \"IF accommodation price is affordable AND accommodation review is excellent                                                                  AND food safety is high     THEN visiting experience is great\",  \"IF accommodation price is cut-rate AND accommodation review is excellent AND food safety is high     THEN visiting experience is great\")  # Adding these rules to the FSI model previously instantiated: fsi <- fsi_add_rules(fsi, rules)  # Defining the query window that is defined over an application domain pts_qw1 <- rbind(c(-73.92, 40.68527), c(-73.75, 40.68527),                   c(-73.75, 40.75), c(-73.92, 40.75), c(-73.92, 40.68527)) qw1 <- st_polygon(list(pts_qw1))  # Example using the discretization approach: dis_res <- fsi_qw_eval(fsi, qw1, approach = \"discretization\", target_lval = \"great\", k = 25)  ## Example using the pso approach in two levels: if (FALSE) { pso_res <- fsi_qw_eval(fsi, qw1, approach = \"pso\", max_depth = 2) }"},{"path":"https://accarniel.github.io/fsr/reference/fsr_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Creation of a component — fsr_components","title":"Creation of a component — fsr_components","text":"two functions build component coordinate pairs single sfg object labeled membership degree. component can added spatial plateau object. component consists sfg object associated membership degree. component can built two different ways. using function create_component, component formed means  numeric vector, list matrix represents pair coordinates. using function component_from_sfg, component created sfg object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creation of a component — fsr_components","text":"","code":"create_component(raw_obj, md, type)  component_from_sfg(sfg, md)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creation of a component — fsr_components","text":"raw_obj vector, list matrix containing pairs coordinates  create sfg object component. md numeric value indicating membership degree component. value \\(]0, 1]\\). type character value indicates type desired sfg object. either \"POINT\", \"LINE\", \"REGION\". sfg sfg object. either POINT, MULTIPOINT, LINESTRING, MULTILINESTRING, POLYGON MULTIPOLYGON type. types spatial objects allowed.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creation of a component — fsr_components","text":"component object can added spatial plateau object (.e., pgeometry object).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_components.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creation of a component — fsr_components","text":"functions create component object, pair sfg object membership degree \\(]0, 1]\\). function create_component receives  three parameters: raw_obj, md type. use raw_obj similar parameter family functions sf package (st family) creates spatial objects numeric vector, matrix list (e.g., functions st_point, st_multipoint, etc.). spatial data type (.e., type sfg object) indicated parameter type represents simple complex objects. instance, \"POINT\" may refer simple complex point objects (internally, can create POINT MULTIPOINT object). component_from_sfg builds component object using specification two parameters directly represents pair sfg object corresponding membership degree (.e.,  md value).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_components.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creation of a component — fsr_components","text":"","code":"# Creating two components of the type POINT v1 = rbind(c(1,2), c(3,4)) v2 = rbind(c(1,4), c(2,3),c(4,4))  md1 = 0.2 md2 = 0.1  comp1 <- create_component(v1, md1, type=\"POINT\") comp2 <- create_component(v2, md2, type=\"POINT\")  # Creating two components of the type LINE  md3 = 0.45 md4 = 0.32  v3 = rbind(c(2,2), c(3,3)) v4 = rbind(c(1,1), c(3,2))  comp3 <- create_component(v3, md3, type=\"LINE\") comp4 <- create_component(v4, md4, type=\"LINE\")  # Creating two components of the type REGION  p1 <- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)) p2 <- rbind(c(1,1), c(1,2), c(2,2), c(1,1)) list_pols_1 <- list(p1,p2)  p3 <- rbind(c(1,0), c(2,0), c(4,2), c(3,4), c(2,4), c(1,0)) p4 <- rbind(c(2,2), c(2,3), c(3,4), c(2,2)) list_pols_2 <- list(p3,p4)  comp_pol1 <- create_component(list_pols_1, 0.4, \"REGION\") comp_pol2 <- create_component(list_pols_2, 0.6, \"REGION\")   # Creating components with an sfg object library(sf)  # POINT md1 <- 0.2 pts1 <- rbind(c(1, 2), c(3, 2)) comp1 <- component_from_sfg(st_multipoint(pts1), md1)   # LINE md2 <- 0.1 pts2 <- rbind(c(2, 2), c(3, 3)) comp2 <- component_from_sfg(st_linestring(pts2), md2)   # REGION md3 <- 0.4 matrix_object = matrix(c(1,1,8,1,8,8,1,8,1,1),ncol=2, byrow=TRUE) pts3 = list(matrix_object) comp3 = component_from_sfg(st_polygon(pts3), md3)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_diff_operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy difference operators — fsr_diff_operators","title":"Fuzzy difference operators — fsr_diff_operators","text":"Fuzzy difference operations set operations generalize Boolean difference operations. family functions implements operators help us define different fuzzy difference operations. operators receive two numerical values [0, 1] input calculates another numerical value [0, 1] output.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_diff_operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy difference operators — fsr_diff_operators","text":"","code":"f_diff(x, y)  f_bound_diff(x, y)  f_symm_diff(x, y)  f_abs_diff(x, y)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_diff_operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy difference operators — fsr_diff_operators","text":"x numerical vector whose values [0, 1]. y numerical vector whose values [0, 1].","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_diff_operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy difference operators — fsr_diff_operators","text":"numerical vector.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_diff_operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy difference operators — fsr_diff_operators","text":"functions calculate resulting membership degree fuzzy difference operator applied two numerical values interval [0, 1]. following fuzzy difference operators available: f_diff: standard fuzzy set difference operator defined intersection x complement y, , min(x, 1 - y). f_bound_diff: fuzzy bounded difference operator defined x minus y upper bound equal 0, , max(0, x - y). f_symm_diff: fuzzy symmetric difference operator defined union difference x y difference y x, , max(f_diff(x, y), f_diff(y, x)). f_abs_diff: fuzzy absolute difference operator defined absolute difference x y, , abs(x - y). operators useful process function spa_difference since one can informed parameter function.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_diff_operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy difference operators — fsr_diff_operators","text":"","code":"x <- c(0.1, 0.3, 0.6, 0.8) y <- c(0.9, 0.7, 0.4, 0.2)  f_diff(x, y) #> [1] 0.1 0.3 0.6 0.8 f_bound_diff(x, y) #> [1] 0.0 0.0 0.2 0.6 f_symm_diff(x, y) #> [1] 0.9 0.7 0.6 0.8 f_abs_diff(x, y) #> [1] 0.8 0.4 0.2 0.6"},{"path":"https://accarniel.github.io/fsr/reference/fsr_eval_modes.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluation modes — fsr_eval_modes","title":"Evaluation modes — fsr_eval_modes","text":"family functions implements evaluation modes returns Boolean value given degree [0, 1] obtained membership function linguistic value.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_eval_modes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluation modes — fsr_eval_modes","text":"","code":"soft_eval(degree)  strict_eval(degree)  alpha_eval(degree, alpha)  soft_alpha_eval(degree, alpha)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_eval_modes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluation modes — fsr_eval_modes","text":"degree numerical vector whose values [0, 1]. alpha single numeric value [0, 1].","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_eval_modes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluation modes — fsr_eval_modes","text":"Boolean vector.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_eval_modes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluation modes — fsr_eval_modes","text":"functions yield Boolean value express meaning degree returning evaluation membership function. , parameter degree value [0, 1] resulting evaluation value membership degree. , evaluation mode \"translate\" meaning degree truth Boolean value. different ways make kind translation: soft_eval: returns TRUE degree greater 0. strict_eval: returns TRUE degree equal 0. alpha_eval: returns TRUE degree greater equal another value (named alpha). soft_alpha_eval: returns TRUE degree greater another value (named alpha). operators employed process evaluation modes fuzzy topological relationships processed Boolean predicates.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_eval_modes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluation modes — fsr_eval_modes","text":"","code":"x <- c(0.1, 0.3, 0.6, 0.8)  soft_eval(x) #> [1] TRUE TRUE TRUE TRUE strict_eval(x) #> [1] FALSE FALSE FALSE FALSE alpha_eval(x, 0.3) #> [1] FALSE  TRUE  TRUE  TRUE soft_alpha_eval(x, 0.3) #> [1] FALSE FALSE  TRUE  TRUE"},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy geometric set operations — fsr_geometric_operations","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"Fuzzy geometric set operations given family functions implements spatial plateau set operations. functions yield spatial plateau object specific combination two spatial plateau objects, intersection two plateau region objects.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"","code":"spa_intersection(pgo1, pgo2, itype = \"min\")  spa_union(pgo1, pgo2, utype = \"max\")  spa_difference(pgo1, pgo2, dtype = \"f_diff\")  spa_common_points(pline1, pline2, itype = \"min\")"},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"pgo1 pgeometry object type. pgo2 pgeometry object type pgo1. itype character value indicates name function implementing t-norm. default value \"min\", standard operator intersection. utype character value refers t-conorm. default value \"max\", standard operator union. dtype character value indicates name difference operator. default value \"f_diff\", implements standard fuzzy difference. pline1 pgeometry object type PLATEAULINE. pline2 pgeometry object type PLATEAULINE.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"pgeometry object result geometric manipulation two spatial plateau objects.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"functions implement geometric operations spatial plateau algebra. receive two pgeometry objects type together operation inputs yield another pgeometry object output. output object type inputs. family fuzzy geometric set operations consists following functions: spa_intersection computes geometric intersection two spatial plateau objects. membership degree common points calculated using t-norm operator given parameter itype. Currently, can assume \"min\" (default) \"prod\". spa_union computes geometric union two spatial plateau objects. membership degree common points calculated using t-conorm operator given parameter utype. Currently, can assume \"max\" (default). spa_difference computes geometric difference two spatial plateau objects. membership degree common points calculated using diff operator given parameter dtype. Currently, can assume \"f_diff\" (default fuzzy difference), \"f_bound_diff\" (fuzzy bounded difference), \"f_symm_diff\" (fuzzy symmetric difference), \"f_abs_diff\" (fuzzy absolute difference). Another related geometric function : spa_common_points gets common points two plateau line objects using t-norm compute membership degrees. different functions since gets two plateau line objects input yields plateau point object output. t-norms, t-conorms, diff operators can implemented given values \"itype\", \"utype\", \"dtype\", respectively. , following steps performed: 1 - implement function accepts two numeric values inputs yields another numeric value output. values 0 1. Recall t-norms t-conorms must specific properties according fuzzy set theory. 2 - use name function character value corresponding \"itype\", \"utype\", \"dtype\". example operator source code f_bound_diff: f_bound_diff <- function(x, y) { max(0, (x - y)) }","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_geometric_operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy geometric set operations — fsr_geometric_operations","text":"","code":"library(sf)  pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  cp1 <- component_from_sfg(st_multipoint(pts1), 0.3) cp2 <- component_from_sfg(st_multipoint(pts2), 0.6) cp3 <- component_from_sfg(st_multipoint(pts3), 1)  pp1 <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAUPOINT\")  pts4 <- rbind(c(0, 0), c(1, 1)) pts5 <- rbind(c(2, 3), c(1.2, 1.9), c(2, 1)) pts6 <- rbind(c(3, 1), c(1.5, 0.5))  cp4 <- component_from_sfg(st_multipoint(pts4), 0.4) cp5 <- component_from_sfg(st_multipoint(pts5), 1) cp6 <- component_from_sfg(st_multipoint(pts6), 0.7)  pp2 <- create_pgeometry(list(cp4, cp5, cp6), \"PLATEAUPOINT\")  pp1 #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.3), (MULTIPOINT ((1 1), (2 3), (2 1)), 0.6), (MULTIPOINT ((2 2), (3 3)), 1))\" pp2 #> [1] \"PLATEAUPOINT ((MULTIPOINT ((0 0), (1 1)), 0.4), (MULTIPOINT ((3 1), (1.5 0.5)), 0.7), (MULTIPOINT ((2 3), (1.2 1.9), (2 1)), 1))\"  spa_intersection(pp1, pp2) #> [1] \"PLATEAUPOINT ((POINT (1 1), 0.4), (MULTIPOINT ((2 1), (2 3)), 0.6))\" spa_intersection(pp1, pp2, itype = \"prod\") #changing the t-norm #> [1] \"PLATEAUPOINT ((POINT (1 1), 0.24), (MULTIPOINT ((2 1), (2 3)), 0.6))\" spa_union(pp1, pp2) #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.3), (POINT (0 0), 0.4), (POINT (1 1), 0.6), (MULTIPOINT ((1.5 0.5), (3 1)), 0.7), (MULTIPOINT ((2 1), (2 2), (2 3), (3 3), (1.2 1.9)), 1))\" spa_difference(pp1, pp2) #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.3), (POINT (1 1), 0.6), (MULTIPOINT ((2 2), (3 3)), 1))\""},{"path":"https://accarniel.github.io/fsr/reference/fsr_is_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Checking whether a pgeometry object is empty — fsr_is_empty","title":"Checking whether a pgeometry object is empty — fsr_is_empty","text":"function checks whether pgeometry object empty (.e., contain components).","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_is_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checking whether a pgeometry object is empty — fsr_is_empty","text":"","code":"fsr_is_empty(pgo)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_is_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checking whether a pgeometry object is empty — fsr_is_empty","text":"pgo pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_is_empty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checking whether a pgeometry object is empty — fsr_is_empty","text":"Boolean value indicates pgeometry empty.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_is_empty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Checking whether a pgeometry object is empty — fsr_is_empty","text":"checks pgeometry object component . number components pgeometry object equal 0, returns  TRUE. Otherwise, returns FALSE.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_is_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checking whether a pgeometry object is empty — fsr_is_empty","text":"","code":"# Creating an empty pgeometry object  pgo1 <- create_empty_pgeometry(\"PLATEAULINE\")  # Checking if it is empty fsr_is_empty(pgo1) #> [1] TRUE  # Creating a component to populate the pgeometry object  library(sf) md <- 0.4 pts <- rbind(c(1, 1), c(2, 3), c(2, 1))  comp <- component_from_sfg(st_multipoint(pts), md)  # Adding the component to the pgeometry object pgo1 <- spa_add_component(pgo1, comp)  # Checking if it is still empty fsr_is_empty(pgo1)  #> [1] FALSE"},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy numerical operations — fsr_numerical_operations","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"Fuzzy numerical operations given family functions implements spatial plateau metric operations. functions extract metric properties spatial plateau objects, area plateau region object length plateau line object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"","code":"spa_avg_degree(pgo)  spa_ncomp(pgo)  spa_area(pr)  spa_perimeter(pr)  spa_length(pl)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"pgo pgeometry object type. pr pgeometry object type PLATEAUREGION. throws error different type given. pl pgeometry object type PLATEAULINE. throws error different type given.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"numerical value.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"functions calculate numerical properties spatial plateau objects (.e., pgeometry objects). type-independent. means parameter can pgeometry object type. type-independent functions : spa_avg_degree calculates average membership degree spatial plateau object. spa_ncomp returns number components spatial plateau object. remaining functions type-dependent. means parameter specific type. type-dependent functions : spa_area computes area plateau region object. Thus, parameter PLATEAUREGION object. spa_perimeter computes perimeter plateau region object. Thus, parameter PLATEAUREGION object. spa_length computes length plateau line object. Thus, parameter PLATEAULINE object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_numerical_operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy numerical operations — fsr_numerical_operations","text":"","code":"library(sf) library(tibble)  pts1 <- rbind(c(1, 2), c(3, 2)) comp1 <- component_from_sfg(st_multipoint(pts1), 0.2)  comp2 <- component_from_sfg(st_point(c(1, 5)), 0.8)    pp <- create_pgeometry(list(comp1, comp2), \"PLATEAUPOINT\")  # calculating the average degree and number of components of pp  spa_avg_degree(pp) #> [1] 0.5 spa_ncomp(pp) #> [1] 2  # calculating the area and perimeter  set.seed(345)  # some random points to create plateau region objects by using the function spa_creator tbl = tibble(x = runif(10, min= 0, max = 20),               y = runif(10, min = 0, max = 30),               z = runif(10, min = 0, max = 100))  #getting the convex hull on the points to clip the construction of plateau region objects pts <- st_as_sf(tbl, coords = c(1, 2)) ch <- st_convex_hull(do.call(c, st_geometry(pts)))  pregions <- spa_creator(tbl, fuzz_policy = \"fcp\", k = 2, base_poly = ch)  spa_area(pregions$pgeometry[[1]]) #> [1] 154.465 spa_area(pregions$pgeometry[[2]]) #> [1] 91.04069  spa_perimeter(pregions$pgeometry[[1]]) #> [1] 104.6208 spa_perimeter(pregions$pgeometry[[2]]) #> [1] 97.09017  # calculating the length of a plateau line object  lpts1 <- rbind(c(0, 0), c(1, 1)) lpts2 <- rbind(c(1, 1), c(1.2, 1.9), c(2, 1)) lpts3 <- rbind(c(2, 1), c(1.5, 0.5))  cp1 <- component_from_sfg(st_linestring(lpts1), 0.4) cp2 <- component_from_sfg(st_linestring(lpts2), 1) cp3 <- component_from_sfg(st_linestring(lpts3), 0.7)  pline <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAULINE\")  spa_length(pline) #> [1] 3.186774"},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy topological relationships — fsr_topological_relationships","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"Fuzzy topological relationships given family functions implements spatial plateau topological relationships. fuzzy topological relationship expresses particular relative position two spatial plateau objects. Since spatial objects fuzzy, topological relationships also fuzzy. Hence, fuzzy topological relationship determines degree relation holds two spatial plateau objects real value interval [0, 1]. key idea relationships consider point subsets resulting combination spatial plateau set operations spatial plateau metric operations spatial plateau objects computing resulting degree. resulting degree can also interpreted linguistic value.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"","code":"spa_overlap(pgo1, pgo2, itype = \"min\", ret = \"degree\", ...)  spa_meet(pgo1, pgo2, itype = \"min\", ret = \"degree\", ...)  spa_disjoint(pgo1, pgo2, itype = \"min\", ret = \"degree\", ...)  spa_equal(pgo1, pgo2, utype = \"max\", ret = 'degree', ...)  spa_inside(pgo1, pgo2, utype = \"max\", ret = 'degree', ...)  spa_contains(pgo1, pgo2, utype = \"max\", ret = 'degree', ...)"},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"pgo1 pgeometry object type PLATEAUREGION. pgo2 pgeometry object type PLATEAUREGION. itype character value indicates name function implementing t-norm. default value \"min\", standard operator intersection. ret character value indicates return type fuzzy topological relationship. default value \"degree\" possible values \"list\" \"bool\". ... <dynamic-dots> ret = \"bool\", two additional parameters informed, described . utype character value indicates name function implementing t-conorm. default value \"max\", standard operator union.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"returning value determined parameter ret, described .","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"functions implement topological relationships spatial plateau algebra. receive two pgeometry objects type PLATEAUREGION together additional parameters (detailed ). family fuzzy topological relationships consists following functions: spa_overlap computes overlapping degree two plateau region objects. Since uses intersection operation, t-norm operator can given parameter itype. Currently, can assume \"min\" (default) \"prod\". spa_meet computes meeting degree two plateau region objects. Similarly spa_overlap, t-norm operator can given parameter itype. spa_disjoint computes disjointedness degree two plateau region objects. Similarly spa_overlap spa_meet, t-norm operator can given parameter itype. spa_equal - computes equal two plateau region objects. Since uses union operation, t-conorm operator can given parameter utype. Currently, can assume \"max\" (default). spa_inside - computes containment degree pgo1 pgo2. Similarly spa_equal, t-conorm operator can given parameter utype. spa_contains - spa_inside changing order operands pgo1 pgo2. parameter ret determines returning value fuzzy topological relationship. default value following: \"degree\" (default) - indicates function return value [0, 1] represents degree truth given topological relationships. remainder possible values, functions make use set linguistic values characterize different situations topological relationships. linguistic value associated membership function defined domain [0, 1]. fsr package default set linguistic values. can use function spa_set_classification change set linguistic values. remainder possible values parameter ret : \"list\" - indicates function return named list containing much result predicate belongs linguistic value (.e., employs membership functions linguistic values). \"bool\" - indicates function return Boolean value indicating whether degree returned topological relationship matches given linguistic value according evaluation mode. evaluation mode linguistic values informed using parameters eval_mode lval, respectively. possible values eval_mode : \"soft_eval\", \"strict_eval\", \"alpha_eval\", \"soft_alpha_eval\". different behavior computing Boolean value membership function linguistic value. See documentations details. Note parameter lval accept character value belonging set linguistic values characterize different situations topological relationships.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/fsr_topological_relationships.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy topological relationships — fsr_topological_relationships","text":"","code":"library(tibble) library(sf) library(FuzzyR)  set.seed(456)  # some random points to create pgeometry objects by using the function spa_creator tbl = tibble(x = runif(10, min= 0, max = 30),               y = runif(10, min = 0, max = 30),               z = runif(10, min = 0, max = 50))  #getting the convex hull on the points to clipping the construction of plateau region objects pts <- st_as_sf(tbl, coords = c(1, 2)) ch <- st_convex_hull(do.call(c, st_geometry(pts)))  pregions <- spa_creator(tbl, base_poly = ch, fuzz_policy = \"fcp\", k = 2)  # Showing the different types of returning values spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]]) #> [1] 0.03952635 spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") #> $small #> [1] 0.1317545 #>  #> $medium #> [1] 0 #>  #> $large #> [1] 0 #>  spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"bool\",             eval_mode = \"soft_eval\", lval = \"mostly\") #> logical(0)  ## Examples for evaluating the other fuzzy topological relationships if (FALSE) {  spa_meet(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") spa_disjoint(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") spa_equal(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") spa_inside(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") spa_contains(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") }"},{"path":"https://accarniel.github.io/fsr/reference/pgeometry-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An S4 Class for representing a spatial plateau object — pgeometry-class","title":"An S4 Class for representing a spatial plateau object — pgeometry-class","text":"S4 Class representing spatial plateau object","code":""},{"path":"https://accarniel.github.io/fsr/reference/pgeometry-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"An S4 Class for representing a spatial plateau object — pgeometry-class","text":"pgeometry object composed list component objects, sfg object represents union crisp spatial objects components (.e., support), data type, can either PLATEAUPOINT, PLATEAULINE, PLATEAUREGION.","code":""},{"path":"https://accarniel.github.io/fsr/reference/pgeometry-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"An S4 Class for representing a spatial plateau object — pgeometry-class","text":"component list components. supp sfg object stores union spatial objects components spatial plateau object. type data type spatial plateau object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/pgeometry-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"An S4 Class for representing a spatial plateau object — pgeometry-class","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualization of pgeometry objects — plot","title":"Visualization of pgeometry objects — plot","text":"function plots pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualization of pgeometry objects — plot","text":"","code":"# S4 method for pgeometry,missing plot(x, y, ...)  fsr_plot(pgo, base_poly = NULL, add_base_poly = TRUE,             low = \"white\", high = \"black\", crs = NA, ...)"},{"path":"https://accarniel.github.io/fsr/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualization of pgeometry objects — plot","text":"x pgeometry object type. y applicable. ... <dynamic-dots> Optional parameters. can parameters geom_sf function. pgo pgeometry object type. base_poly sfg object type POLYGON MULTIPOLYGON. can also sfc object one element type POLYGON MULTIPOLYGON. add_base_poly Boolean value indicates whether base_poly added visualization. low character value indicates color lower mds limit value (0). Default \"white\". high character value indicates color higher mds limit value (1). Default \"black\". crs numerical value denotes coordinate reference system (.e., EPSG code) visualization. Default NA.","code":""},{"path":"https://accarniel.github.io/fsr/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualization of pgeometry objects — plot","text":"ggplot object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualization of pgeometry objects — plot","text":"fsr_plot uses ggplot method construct plot. receives pgeometry object (empty, empty graphics obtained). low high parameters colors minimum maximum limits membership degrees. default colors \"white\" \"black\", respectively. colors can given way colors informed visualizations produced ggplot package. possible clip geometric format components using parameter base_poly. boundaries object can also included visualization parameter add_base_poly TRUE.","code":""},{"path":"https://accarniel.github.io/fsr/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualization of pgeometry objects — plot","text":"","code":"library(sf)  ### Example 1  # Creating components for the plateau point object v1 <- rbind(c(1,2), c(3,4)) v2 <- rbind(c(1,4), c(2,3),c(4,4))  md1 <- 0.2 md2 <- 0.1 md3 <- 0.4 pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  comp1 <- component_from_sfg(st_multipoint(pts1), md1) comp2 <- component_from_sfg(st_multipoint(pts2), md2) comp3 <- component_from_sfg(st_multipoint(pts3), md3)  # Creating the plateau point object as a pgeometry object with 3 components  ppoint <- create_pgeometry(list(comp1, comp2, comp3), \"PLATEAUPOINT\")  fsr_plot(ppoint) # with default colors  fsr_plot(ppoint, low=\"blue\",high = \"red\") # with custom limit colors   # Example 2 - PLATEAULINE PLOT  lpts1 <- rbind(c(0, 0), c(1, 1)) lpts2 <- rbind(c(1, 1), c(1.2, 1.9), c(2, 1)) lpts3 <- rbind(c(2, 1), c(1.5, 0.5))  comp4 <- component_from_sfg(st_linestring(lpts1), 0.4) comp5 <- component_from_sfg(st_linestring(lpts2), 1) comp6 <- component_from_sfg(st_linestring(lpts3), 0.7)  pline <- create_pgeometry(list(comp4, comp5, comp6), \"PLATEAULINE\")  fsr_plot(pline) # Default values  fsr_plot(pline, low=\"green\", high=\"blue\") # Custom colors ...    # Example 3 - PLATEAUREGION PLOT  p1 <- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)) p2 <- rbind(c(1,1), c(1,2), c(2,2), c(1,1)) pol1 <-st_polygon(list(p1,p2)) p3 <- rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0)) p4 <- rbind(c(3.3,0.3), c(3.8,0.3), c(3.8,0.8), c(3.3,0.8), c(3.3,0.3))[5:1,] pol2 <- st_polygon(list(p3,p4)) pol3 <- st_polygon(list(rbind(c(3,3), c(4,2), c(4,3), c(3,3))))  comp1 <- component_from_sfg(pol1, 0.2) comp2 <- component_from_sfg(pol2, 0.4) comp3 <- component_from_sfg(pol3, 0.7)  pregion <- create_pgeometry(list(comp1, comp2, comp3), \"PLATEAUREGION\") fsr_plot(pregion)  fsr_plot(pregion, low = \"blue\", high = \"red\")"},{"path":"https://accarniel.github.io/fsr/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. tibble as_tibble","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":null,"dir":"Reference","previous_headings":"","what":"Adding components to a pgeometry object — spa_add_component","title":"Adding components to a pgeometry object — spa_add_component","text":"function adds components spatial plateau object (.e., pgeometry object). crisp spatial object component must compatible type plateau spatial object. instance, pgeometry object type PLATEAUREGION accepts components containing polygons (e.g., POLYGON MULTIPOLYGON).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adding components to a pgeometry object — spa_add_component","text":"","code":"spa_add_component(pgo, components)"},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adding components to a pgeometry object — spa_add_component","text":"pgo pgeometry object type. components component object list component objects.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adding components to a pgeometry object — spa_add_component","text":"pgeometry object containing component objects.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adding components to a pgeometry object — spa_add_component","text":"function implements \\(\\odot\\) operator defined Spatial Plateau Algebra. goal function insert component list components pgeometry object. insertion based membership degree component (e.g., created component_from_sfg). Thus, preserves properties spatial plateau object. However, function assumes component compatible pgeometry object geometric format valid (.e., overlap existing components).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Adding components to a pgeometry object — spa_add_component","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_add_component.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adding components to a pgeometry object — spa_add_component","text":"","code":"library(sf)  pts1 <- rbind(c(1, 2), c(3, 2)) comp1 <- component_from_sfg(st_multipoint(pts1), 0.2)  comp2 <- component_from_sfg(st_point(c(1, 5)), 0.8)    # appending these components into an empty pgeometry object  pp <- create_empty_pgeometry(\"PLATEAUPOINT\") pp <- spa_add_component(pp, list(comp1, comp2)) pp #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.2), (POINT (1 5), 0.8))\""},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":null,"dir":"Reference","previous_headings":"","what":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"function yields specific part fuzzy boundary plateau region object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"","code":"spa_boundary_pregion(pregion, bound_part = \"region\")"},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"pregion pgeometry object type PLATEAUREGION. throws error different type given. bound_part character value indicates part fuzzy boundary returned. can \"region\" \"line\". See details.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"pgeometry object represents specific part fuzzy boundary pgeometry object given input.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"employs definition fuzzy boundary fuzzy region object context spatial plateau algebra (defined references). fuzzy boundary fuzzy region object heterogeneous nature since consists two parts: fuzzy line object corresponds boundary core . fuzzy region object comprises points membership degree greater 0 less 1. means function spa_boundary_pregion can yield one specific part fuzzy boundary plateau region object (argument pgeometry). boundary = \"line\", function returns boundary plateau line pgeometry (.e., returns pgeometry object type PLATEAULINE). Else boundary = \"region\" (default value), function returns boundary plateau region pgeometry (.e., returns pgeometry object type PLATEAUREGION).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"Carniel, . C.; Schneider, M. Conceptual Model Fuzzy Topological Relationships Fuzzy Regions. Proceedings 2016 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016. Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_boundary_pregion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capturing the fuzzy boundary of a plateau region object — spa_boundary_pregion","text":"","code":"library(tibble) library(FuzzyR)  set.seed(123)  # some random points to create pgeometry objects by using the function spa_creator tbl = tibble(x = runif(10, min= 0, max = 30),               y = runif(10, min = 0, max = 50),               z = runif(10, min = 0, max = 100))  classes <- c(\"category-1\", \"category-2\") mf1 <- genmf(\"trapmf\", c(0, 5, 20, 35)) mf2 <- genmf(\"trimf\", c(20, 80, 100))  pregions <- spa_creator(tbl, classes = classes, mfs = c(mf1, mf2)) pregions$pgeometry[[1]] #> [1] \"PLATEAUREGION ((POLYGON ((-10.8192 18.97073, 15.0174 25.2867, 25.22269 13.72177, 24.46465 12.93535, -10.8192 18.97073)), 0.405601751369735), (POLYGON ((12.21485 93.58036, 73.95271 93.58036, 73.95271 74.26182, 22.53832 39.81573, 11.0072 41.00587, 12.21485 93.58036)), 1))\" pregions$pgeometry[[2]] #> [1] \"PLATEAUREGION ((POLYGON ((73.95271 74.26182, 73.95271 20.30876, 41.31009 17.91326, 18.4713 28.79236, 22.53832 39.81573, 73.95271 74.26182)), 0.0286511168815196), (POLYGON ((-10.8192 18.97073, 15.0174 25.2867, 25.22269 13.72177, 24.46465 12.93535, -10.8192 18.97073)), 0.148599562157566), (POLYGON ((-13.51886 93.58036, 12.21485 93.58036, 11.0072 41.00587, 7.48209 40.08642, -13.51886 93.58036)), 0.552303419681266), (POLYGON ((-26.14517 -43.63571, -44.372 -43.63571, -44.372 5.185215, -14.69493 18.3287, -10.8192 18.97073, 24.46465 12.93535, 20.88759 6.753414, -26.14517 -43.63571)), 0.573443374518926), (POLYGON ((73.95271 -18.38102, 73.95271 -43.63571, -26.14517 -43.63571, 20.88759 6.753414, 73.95271 -18.38102)), 0.656903367411966), (POLYGON ((7.48209 40.08642, 11.0072 41.00587, 22.53832 39.81573, 18.4713 28.79236, 15.0174 25.2867, -10.8192 18.97073, -14.69493 18.3287, 7.48209 40.08642)), 0.734178022947162), (POLYGON ((73.95271 20.30876, 73.95271 -18.38102, 20.88759 6.753414, 24.46465 12.93535, 25.22269 13.72177, 41.31009 17.91326, 73.95271 20.30876)), 0.759509665193036), (POLYGON ((15.0174 25.2867, 18.4713 28.79236, 41.31009 17.91326, 25.22269 13.72177, 15.0174 25.2867)), 0.821339010260999), (POLYGON ((-44.372 5.185215, -44.372 93.58036, -13.51886 93.58036, 7.48209 40.08642, -14.69493 18.3287, -44.372 5.185215)), 0.847550780279562))\"  # capturing and showing the boundary plateau line of each pgeometry object previously created (spa_boundary_pregion(pregions$pgeometry[[1]], bound_part = \"line\"))  #> [1] \"PLATEAULINE ((LINESTRING (12.21485 93.58036, 73.95271 93.58036, 73.95271 74.26182, 22.53832 39.81573, 11.0072 41.00587, 12.21485 93.58036), 1))\" (spa_boundary_pregion(pregions$pgeometry[[2]], bound_part = \"line\")) #> [1] \"PLATEAULINE EMPTY\" # the last boundary is empty because there is no core!   # capturing and showing the boundary plateau region (this is the default behavior) (spa_boundary_pregion(pregions$pgeometry[[1]])) #> [1] \"PLATEAUREGION ((POLYGON ((-10.8192 18.97073, 15.0174 25.2867, 25.22269 13.72177, 24.46465 12.93535, -10.8192 18.97073)), 0.405601751369735))\" (spa_boundary_pregion(pregions$pgeometry[[2]])) #> [1] \"PLATEAUREGION ((POLYGON ((73.95271 74.26182, 73.95271 20.30876, 41.31009 17.91326, 18.4713 28.79236, 22.53832 39.81573, 73.95271 74.26182)), 0.0286511168815196), (POLYGON ((-10.8192 18.97073, 15.0174 25.2867, 25.22269 13.72177, 24.46465 12.93535, -10.8192 18.97073)), 0.148599562157566), (POLYGON ((-13.51886 93.58036, 12.21485 93.58036, 11.0072 41.00587, 7.48209 40.08642, -13.51886 93.58036)), 0.552303419681266), (POLYGON ((-26.14517 -43.63571, -44.372 -43.63571, -44.372 5.185215, -14.69493 18.3287, -10.8192 18.97073, 24.46465 12.93535, 20.88759 6.753414, -26.14517 -43.63571)), 0.573443374518926), (POLYGON ((73.95271 -18.38102, 73.95271 -43.63571, -26.14517 -43.63571, 20.88759 6.753414, 73.95271 -18.38102)), 0.656903367411966), (POLYGON ((7.48209 40.08642, 11.0072 41.00587, 22.53832 39.81573, 18.4713 28.79236, 15.0174 25.2867, -10.8192 18.97073, -14.69493 18.3287, 7.48209 40.08642)), 0.734178022947162), (POLYGON ((73.95271 20.30876, 73.95271 -18.38102, 20.88759 6.753414, 24.46465 12.93535, 25.22269 13.72177, 41.31009 17.91326, 73.95271 20.30876)), 0.759509665193036), (POLYGON ((15.0174 25.2867, 18.4713 28.79236, 41.31009 17.91326, 25.22269 13.72177, 15.0174 25.2867)), 0.821339010260999), (POLYGON ((-44.372 5.185215, -44.372 93.58036, -13.51886 93.58036, 7.48209 40.08642, -14.69493 18.3287, -44.372 5.185215)), 0.847550780279562))\""},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":null,"dir":"Reference","previous_headings":"","what":"Capturing the frontier of a plateau region object — spa_contour","title":"Capturing the frontier of a plateau region object — spa_contour","text":"function extracts frontier (.e., linear boundary) plateau region object maintaining membership degrees.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capturing the frontier of a plateau region object — spa_contour","text":"","code":"spa_contour(pregion)"},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capturing the frontier of a plateau region object — spa_contour","text":"pregion pgeometry object type PLATEAUREGION. throws error different type given.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capturing the frontier of a plateau region object — spa_contour","text":"pgeometry object type PLATEAULINE represents contour (.e. frontier) plateau region object given input.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Capturing the frontier of a plateau region object — spa_contour","text":"employs definition fuzzy frontier fuzzy region object context spatial plateau algebra (defined references). fuzzy frontier fuzzy region object collects single points , preserving membership degrees, interior support. IMPORTANT NOTE: Fuzzy frontier different fuzzy boundary (see spa_boundary_region).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capturing the frontier of a plateau region object — spa_contour","text":"Carniel, . C.; Schneider, M. Conceptual Model Fuzzy Topological Relationships Fuzzy Regions. Proceedings 2016 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016. Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_contour.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capturing the frontier of a plateau region object — spa_contour","text":"","code":"library(tibble) library(sf) library(FuzzyR)  set.seed(123)  # some random points to create pgeometry objects by using the function spa_creator tbl = tibble(x = runif(10, min= 0, max = 30),               y = runif(10, min = 0, max = 50),               z = runif(10, min = 0, max = 100))  classes <- c(\"category-1\", \"category-2\") mf1 <- genmf(\"trapmf\", c(0, 5, 20, 35)) mf2 <- genmf(\"trimf\", c(35, 80, 100))  #getting the convex hull on the points to clipping the construction of plateau region objects pts <- st_as_sf(tbl, coords = c(1, 2)) ch <- st_convex_hull(do.call(c, st_geometry(pts)))  pregions <- spa_creator(tbl, classes = classes, mfs = c(mf1, mf2), base_poly = ch)  # capturing and showing the frontier of each pgeometry object previously created frontier_pregion1 <- spa_contour(pregions$pgeometry[[1]])  frontier_pregion2 <- spa_contour(pregions$pgeometry[[2]])  plot(pregions$pgeometry[[1]])  plot(frontier_pregion1)   plot(pregions$pgeometry[[2]])  plot(frontier_pregion2)"},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Capturing the core of a pgeometry object — spa_core","title":"Capturing the core of a pgeometry object — spa_core","text":"function yields crisp spatial object (sfg object) corresponds core pgeometry object given input.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capturing the core of a pgeometry object — spa_core","text":"","code":"spa_core(pgo)"},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capturing the core of a pgeometry object — spa_core","text":"pgo pgeometry object type.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capturing the core of a pgeometry object — spa_core","text":"sfg object represents core pgo. can empty object pgo component membership degree 1.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Capturing the core of a pgeometry object — spa_core","text":"employs classical definition core fuzzy set theory context spatial plateau algebra. core comprises points membership degree equal 1. Hence, operation returns sfg object represents component labeled membership degree equal 1 pgeometry object given input. pgeometry object core, empty sfg object returned (.e., crisp spatial object without points).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capturing the core of a pgeometry object — spa_core","text":"Carniel, . C.; Schneider, M. Conceptual Model Fuzzy Topological Relationships Fuzzy Regions. Proceedings 2016 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_core.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capturing the core of a pgeometry object — spa_core","text":"","code":"library(sf)  pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  cp1 <- component_from_sfg(st_multipoint(pts1), 0.3) cp2 <- component_from_sfg(st_multipoint(pts2), 0.6) cp3 <- component_from_sfg(st_multipoint(pts3), 1.0)  pp <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAUPOINT\") pp #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.3), (MULTIPOINT ((1 1), (2 3), (2 1)), 0.6), (MULTIPOINT ((2 2), (3 3)), 1))\"  pp_core <- spa_core(pp) pp_core #> MULTIPOINT ((2 2), (3 3))  #Creating a pgeometry object without core pp2 <- create_pgeometry(list(cp1, cp2), \"PLATEAUPOINT\") pp2 #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.3), (MULTIPOINT ((1 1), (2 3), (2 1)), 0.6))\"  spa_core(pp2) #> POINT EMPTY"},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":null,"dir":"Reference","previous_headings":"","what":"Building pgeometry objects from a point dataset — spa_creator","title":"Building pgeometry objects from a point dataset — spa_creator","text":"function builds set spatial plateau objects given point dataset assigned domain-specific numerical values.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building pgeometry objects from a point dataset — spa_creator","text":"","code":"spa_creator(tbl, fuzz_policy = \"fsp\", const_policy = \"voronoi\", ...)"},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building pgeometry objects from a point dataset — spa_creator","text":"tbl data.frame tibble following format: (x, y, z). fuzz_policy fuzzification policy employed algorithm. See details . const_policy construction policy used algorithm. See details . ... <dynamic-dots> Parameters chosen policies. See details .","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Building pgeometry objects from a point dataset — spa_creator","text":"tibble format (class, pgeometry), class character column pgeometry list pgeometry objects. means spatial plateau object created representing specific class point dataset.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Building pgeometry objects from a point dataset — spa_creator","text":"follows two-stage construction method described research paper reference. input tbl point dataset point represents location phenomenon treated application. , point annotated numerical data describe meaning application. Therefore, tbl must three columns: (x, y, z). columns x, y pair coordinates, z column containing domain-specific numeric values. fuzz_policy refers method used fuzzification stage. stage aims assign membership degrees point dataset. accepts three possible values : \"fsp\" (default), \"fcp\". \"fsp\" stands fuzzy set policy requires two parameters informed ...: classes: character vector containing name classes mfs: vector membership functions generated function genmf FuzzyR package. membership function represents class , length(classes) \"fcp\" stands fuzzy clustering policy requires e1071 package. possible parameters, informed ..., : k: numeric value refers number groups created method: fuzzy clustering method package e1071, can either \"cmeans\" (default) \"cshell\" use_coords: Boolean value indicate whether columns (x, y) used clustering algorithm (default FALSE) iter: numeric indicating number maximum iterations clustering algorithm (default 100) optional common parameter fuzzification stages \"digits\". integer value indicates number decimal digits membership degrees calculated fuzzification stage. , used round membership degrees specified number decimal places. careful optional parameter! specify low value \"digits\" membership degrees rounded 0 thus, components created. const_policy refers method used construction stage. stage aims create polygons labeled point dataset use build spatial plateau objects. accepts two possible values : either \"voronoi\" (default) \"delaunay\". \"voronoi\" stands Voronoi diagram policy one optional parameter can provided ...: base_poly: sfg object used clip generated polygons (optional argument). parameter provided, Voronoi created using bounding box (standard behavior sf). d_tolerance: refers parameter dTolerance employed function st_voronoi package sf. \"delaunay\" stands Delaunay triangulation policy, accepts following parameters ...: base_poly: sfg object used clip generated triangles (optional argument). tnorm: t-norm used calculate membership degree triangle. name vector function. Possible values \"min\" (default), \"prod\". Note possible use t-norms. t-norm following signature: FUN(x) x numeric vector. function return single numeric value. d_tolerance: refers parameter dTolerance employed function st_triangulate package sf. \"convex_hull\" stands Convex hull policy, accepts following parameters ...: M: numeric vector containing membership degrees used create components. default defined seq(0.05, 1, = 0.05). d: numeric value representing tolerance distance compute membership degree elements M membership degrees points. default 0.05. base_poly: sfg object used clip generated polygons (optional argument).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Building pgeometry objects from a point dataset — spa_creator","text":"Carniel, . C.; Schneider, M. Systematic Approach Creating Fuzzy Region Objects Real Spatial Data Sets. Proceedings 2019 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2019), pp. 1-6, 2019.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_creator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Building pgeometry objects from a point dataset — spa_creator","text":"","code":"library(tibble) library(FuzzyR)  set.seed(7) tbl = tibble(x = runif(10, min= 0, max = 30),               y = runif(10, min = 0, max = 50),               z = runif(10, min = 0, max = 100)) classes <- c(\"cold\", \"hot\") cold_mf <- genmf(\"trapmf\", c(0, 10, 20, 35)) hot_mf <- genmf(\"trimf\", c(35, 50, 100))  spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf)) #> # A tibble: 2 × 2 #>   class pgeometry  #>   <chr> <list>     #> 1 cold  <pgeomtry> #> 2 hot   <pgeomtry>  spa_creator(tbl, fuzz_policy = \"fcp\", k = 4) #> # A tibble: 4 × 2 #>   class  pgeometry  #>   <chr>  <list>     #> 1 group1 <pgeomtry> #> 2 group2 <pgeomtry> #> 3 group3 <pgeomtry> #> 4 group4 <pgeomtry>  spa_creator(tbl, fuzz_policy = \"fcp\", k = 4, digits = 2) #> # A tibble: 4 × 2 #>   class  pgeometry  #>   <chr>  <list>     #> 1 group1 <pgeomtry> #> 2 group2 <pgeomtry> #> 3 group3 <pgeomtry> #> 4 group4 <pgeomtry>  spa_creator(tbl, fuzz_policy = \"fcp\", k = 3, const_policy = \"delaunay\") #> # A tibble: 3 × 2 #>   class  pgeometry  #>   <chr>  <list>     #> 1 group1 <pgeomtry> #> 2 group2 <pgeomtry> #> 3 group3 <pgeomtry>  spa_creator(tbl, fuzz_policy = \"fcp\", const_policy = \"delaunay\", k = 3, tnorm = \"prod\") #> # A tibble: 3 × 2 #>   class  pgeometry  #>   <chr>  <list>     #> 1 group1 <pgeomtry> #> 2 group2 <pgeomtry> #> 3 group3 <pgeomtry>  spa_creator(tbl, fuzz_policy = \"fcp\", k = 2, digits = 2,              M = seq(0.1, 1, by = 0.1), d = 0.05, const_policy = \"convex_hull\") #> # A tibble: 2 × 2 #>   class  pgeometry  #>   <chr>  <list>     #> 1 group1 <pgeomtry> #> 2 group2 <pgeomtry>              spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf),              digits = 2, const_policy = \"convex_hull\") #> # A tibble: 2 × 2 #>   class pgeometry  #>   <chr> <list>     #> 1 cold  <pgeomtry> #> 2 hot   <pgeomtry>"},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Capturing the membership degree of a point — spa_eval","title":"Capturing the membership degree of a point — spa_eval","text":"function evaluates membership degree given point spatial plateau object type. returns value [0, 1] indicates extent point belongs pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capturing the membership degree of a point — spa_eval","text":"","code":"spa_eval(pgo, point)"},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capturing the membership degree of a point — spa_eval","text":"pgo pgeometry object type. point sfg object type POINT.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capturing the membership degree of a point — spa_eval","text":"numeric value 0 1 indicates membership degree point (.e., sfg object) spatial plateau object (.e., pgeometry object).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Capturing the membership degree of a point — spa_eval","text":"goal function return membership degree simple point object (.e., sfg object) given spatial plateau object (.e., pgeometry object). evaluation depends following basic cases: simple point object belongs interior boundary one component spatial plateau object, returns membership degree component. simple point object intersects components (e.g., boundaries region components, different line components), returns maximum membership degree intersected components. simple point object disjoint support spatial plateau object, returns 0.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capturing the membership degree of a point — spa_eval","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capturing the membership degree of a point — spa_eval","text":"","code":"library(tibble) library(sf) library(FuzzyR)  # some basic examples   pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  cp1 <- component_from_sfg(st_multipoint(pts1), 0.3) cp2 <- component_from_sfg(st_multipoint(pts2), 0.6) cp3 <- component_from_sfg(st_multipoint(pts3), 1.0)  pp <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAUPOINT\")  spa_eval(pp, st_point(c(1, 2))) #> [1] 0.3 spa_eval(pp, st_point(c(1, 3))) #> [1] 0  # other examples with plateau regions  set.seed(345)  # some random points to create plateau region objects by using the function spa_creator tbl = tibble(x = runif(10, min= 0, max = 20),               y = runif(10, min = 0, max = 30),               z = runif(10, min = 0, max = 100))  #getting the convex hull on the points to clipping the construction of plateau region objects pts <- st_as_sf(tbl, coords = c(1, 2)) ch <- st_convex_hull(do.call(c, st_geometry(pts)))  pregions <- spa_creator(tbl, fuzz_policy = \"fcp\", k = 2, base_poly = ch)  # capturing the membership degree of a specific point in each object spa_eval(pregions$pgeometry[[1]], st_point(c(5, 15))) #> [1] 0.03729989 spa_eval(pregions$pgeometry[[2]], st_point(c(5, 15))) #> [1] 0.9627001"},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Check exact equality — spa_exact_equal","title":"Check exact equality — spa_exact_equal","text":"function checks whether two spatial plateau objects exactly equal.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check exact equality — spa_exact_equal","text":"","code":"spa_exact_equal(pgo1, pgo2)"},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check exact equality — spa_exact_equal","text":"pgo1 pgeometry object type. pgo2 pgeometry object type.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check exact equality — spa_exact_equal","text":"Boolean value indicates two pgeometry objects exactly equal.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check exact equality — spa_exact_equal","text":"Boolean function checks fuzzy equality spatial plateau context. Two pgeometry objects exactly equal components equal. Two components equal membership degree (spatially) equal (.e., sfg objects geometric format - means order points can different).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check exact equality — spa_exact_equal","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check exact equality — spa_exact_equal","text":"","code":"library(sf)  pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  cp1 <- component_from_sfg(st_multipoint(pts1), 0.3) cp2 <- component_from_sfg(st_multipoint(pts2), 0.6) cp3 <- component_from_sfg(st_multipoint(pts3), 1.0)  pp1 <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAUPOINT\") pp2 <- create_pgeometry(list(cp2, cp1), \"PLATEAUPOINT\")  spa_exact_equal(pp1, pp2) #> [1] FALSE  spa_exact_equal(pp1, pp1) #> [1] TRUE"},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":null,"dir":"Reference","previous_headings":"","what":"Check exact containment — spa_exact_inside","title":"Check exact containment — spa_exact_inside","text":"function checks whether pgeometry object completely inside another pgeometry object.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check exact containment — spa_exact_inside","text":"","code":"spa_exact_inside(pgo1, pgo2)"},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check exact containment — spa_exact_inside","text":"pgo1 pgeometry object type. pgo2 pgeometry object type.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check exact containment — spa_exact_inside","text":"Boolean value indicates pgeometry completely certainly inside pgo2.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check exact containment — spa_exact_inside","text":"Boolean function checks fuzzy containment spatial plateau context. Boolean function checks whether components pgo1 contained components pgo2 considering membership degrees geographic positions. , follows classical definition fuzzy containment fuzzy set theory. words, function checks (standard) intersection pgo1 pgo2 exactly equal pgo1. operands affects result.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check exact containment — spa_exact_inside","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_exact_inside.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check exact containment — spa_exact_inside","text":"","code":"library(sf)  pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  cp1 <- component_from_sfg(st_multipoint(pts1), 0.3) cp2 <- component_from_sfg(st_multipoint(pts2), 0.6) cp3 <- component_from_sfg(st_multipoint(pts3), 1.0)  # Creating two spatial plateau objects pp1 <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAUPOINT\") pp2 <- create_pgeometry(list(cp2, cp1), \"PLATEAUPOINT\")  # The other of operands after the result # pp1 is not inside pp2 since it has one point that is not included in pp2 spa_exact_inside(pp1, pp2) #> [1] FALSE  # on the other hand, pp2 is inside pp1 spa_exact_inside(pp2, pp1) #> [1] TRUE"},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting a new classification for fuzzy topological relationships — spa_set_classification","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"functions configures new set linguistic values corresponding membership functions used fuzzy topological relationships.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"","code":"spa_set_classification(classes, mfs)"},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"classes character vector containing linguistic values characterizes different situations fuzzy topological relationships. mfs vector containing membership functions generated function genmf FuzzyR package. domain [0, 1].","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"return values, called side effects.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"function replaces default linguistic values employed fuzzy topological relationships. membership function parameter mfs represents class parameter classes. length parameters .","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"Carniel, . C.; Schneider, M. Spatial Plateau Algebra: Executable Type System Fuzzy Spatial Data Types. Proceedings 2018 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_set_classification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setting a new classification for fuzzy topological relationships — spa_set_classification","text":"","code":"library(tibble) library(sf) library(FuzzyR)  set.seed(456)  # some random points to create pgeometry objects by using the function spa_creator tbl = tibble(x = runif(10, min= 0, max = 30),               y = runif(10, min = 0, max = 30),               z = runif(10, min = 0, max = 50))  #getting the convex hull on the points to clipping the construction of plateau region objects pts <- st_as_sf(tbl, coords = c(1, 2)) ch <- st_convex_hull(do.call(c, st_geometry(pts)))  pregions <- spa_creator(tbl, base_poly = ch, fuzz_policy = \"fcp\", k = 2)  # Showing the default list of classes spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") #> $small #> [1] 0.1317545 #>  #> $medium #> [1] 0 #>  #> $large #> [1] 0 #>   # Changing the default classification  classes <- c(\"small\", \"medium\", \"large\") small <- genmf(\"trapmf\", c(0, 0.3, 0.4, 0.6)) medium <- genmf(\"trapmf\", c(0.4, 0.6, 0.8, 1)) large <- genmf(\"trapmf\", c(0.6, 0.8, 1, 1))  spa_set_classification(classes, c(small, medium, large))  spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = \"list\") #> $small #> [1] 0.1317545 #>  #> $medium #> [1] 0 #>  #> $large #> [1] 0 #>"},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":null,"dir":"Reference","previous_headings":"","what":"Capturing the support of a pgeometry object — spa_support","title":"Capturing the support of a pgeometry object — spa_support","text":"function yields crisp spatial object (sfg object) corresponds support pgeometry object given input.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capturing the support of a pgeometry object — spa_support","text":"","code":"spa_support(pgo)"},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capturing the support of a pgeometry object — spa_support","text":"pgo pgeometry object type.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capturing the support of a pgeometry object — spa_support","text":"sfg object represents support pgeometry. can empty object pgeometry empty.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Capturing the support of a pgeometry object — spa_support","text":"employs classical definition support fuzzy set theory context spatial plateau algebra. support comprises points membership degree greater equal 1. Hence, operation returns sfg object represents total extent pgeometry given input. pgeometry object components, empty sfg object returned (.e., crisp spatial object without points).","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capturing the support of a pgeometry object — spa_support","text":"Carniel, . C.; Schneider, M. Conceptual Model Fuzzy Topological Relationships Fuzzy Regions. Proceedings 2016 IEEE International Conference Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.","code":""},{"path":"https://accarniel.github.io/fsr/reference/spa_support.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capturing the support of a pgeometry object — spa_support","text":"","code":"library(sf)  pts1 <- rbind(c(1, 2), c(3, 2)) pts2 <- rbind(c(1, 1), c(2, 3), c(2, 1)) pts3 <- rbind(c(2, 2), c(3, 3))  cp1 <- component_from_sfg(st_multipoint(pts1), 0.3) cp2 <- component_from_sfg(st_multipoint(pts2), 0.6) cp3 <- component_from_sfg(st_multipoint(pts3), 1.0)  pp <- create_pgeometry(list(cp1, cp2, cp3), \"PLATEAUPOINT\") pp #> [1] \"PLATEAUPOINT ((MULTIPOINT ((1 2), (3 2)), 0.3), (MULTIPOINT ((1 1), (2 3), (2 1)), 0.6), (MULTIPOINT ((2 2), (3 3)), 1))\"  pp_supp <- spa_support(pp) pp_supp #> MULTIPOINT ((1 1), (1 2), (2 1), (2 2), (2 3), (3 2), (3 3))  pp_empty <- create_empty_pgeometry(\"PLATEAUPOINT\") pp_empty_supp <- spa_support(pp_empty) pp_empty_supp #> MULTIPOINT EMPTY"},{"path":"https://accarniel.github.io/fsr/reference/visitation.html","id":null,"dir":"Reference","previous_headings":"","what":"Visitation: An example of FSI model — visitation","title":"Visitation: An example of FSI model — visitation","text":"function provides example, without rules, fuzzy spatial inference (FSI) model.","code":""},{"path":"https://accarniel.github.io/fsr/reference/visitation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visitation: An example of FSI model — visitation","text":"","code":"visitation()"},{"path":"https://accarniel.github.io/fsr/reference/visitation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visitation: An example of FSI model — visitation","text":"example FSI model implemented without fuzzy rules set.","code":""},{"path":"https://accarniel.github.io/fsr/reference/visitation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visitation: An example of FSI model — visitation","text":"FSI model provided function represents FSI model estimate visiting experience based prices overall ratings accommodations well sanitary conditions restaurants. output model infers value 0 100 indicates attractive visit specific location. , experience can classified awful, average, great. linguistic variables linguistic values FSI model listed : accommodation price,  cut-rate, affordable, expensive linguistic values; accommodation review bad, good, excellent linguistic values; food safety low, medium, high linguistic values, represent levels sanitary conditions. usage FSI models subdivided preparation phase evaluation phase. preparation phase responsible instantiating new FSI model elements data source component FIFUS. , fsr package provides following functions: fsi_create, fsi_add_fsa, fsi_add_cs. functions employed visitation users can add fuzzy set rules (using fsi_add_rules) perform evaluation phase (using functions fsi_eval /fsi_qw_eval). sense, visitation performs following internal actions return FSI model: specify linguistic variables corresponding linguistic values, turn represented membership functions generated function genmf FuzzyR package. items specified according context running example. define small point datasets represent linguistic variable. datasets tibble objects. build spatial plateau objects using function spa_creator datasets. result, get spatial plateau objects represent linguistic value. create FSI model fsi_create function. add fuzzy spatial antecedents fsi_add_fsa function. Recall antecedents spatial plateau objects previously built. define linguistic variable linguistic values membership functions consequent. add consequent FSI model using function fsi_add_cs.","code":""},{"path":"https://accarniel.github.io/fsr/reference/visitation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visitation: An example of FSI model — visitation","text":"","code":"fsi <- visitation()"},{"path":[]},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"minor-changes-1-0-2","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"fsr 1.0.2","text":"Add parameter dTolerance function spa_creator. parameter employed package sf computing Voronoi diagram Delaunay triangulation corresponding construction policies.","code":""},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"bug-fixes-1-0-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fsr 1.0.2","text":"Fix fuzzy numerical operations dealing empty objects Fix spa_core return empty crisp spatial object input core Fix statements calculations fuzzy topological relationships Fix clipping operation spa_creator using construction policies based Voronoi diagram Delaunay triangulation","code":""},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"fsr-101","dir":"Changelog","previous_headings":"","what":"fsr 1.0.1","title":"fsr 1.0.1","text":"CRAN release: 2022-01-25","code":""},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"major-changes-1-0-1","dir":"Changelog","previous_headings":"","what":"Major changes","title":"fsr 1.0.1","text":"Add new construction policy spa_creator function based convex hull (improved implementation issue #29)","code":""},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"minor-changes-1-0-1","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"fsr 1.0.1","text":"Add publication describes fsr package CITATION Add optional parameter function spa_creator named digits (improved update based pull request #2, @leticiabohnert)","code":""},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"bug-fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fsr 1.0.1","text":"Fix spa_add_component checking specific condition Fix management CRS plotting spatial plateau objects (function fsr_plot) Fix management geometry collections resulting geometric computations spatial plateau geometric set operations (internal function append_valid_comps)","code":""},{"path":"https://accarniel.github.io/fsr/news/index.html","id":"fsr-100","dir":"Changelog","previous_headings":"","what":"fsr 1.0.0","title":"fsr 1.0.0","text":"CRAN release: 2021-09-16 Fuzzy Spatial Inference Module (e.g., functions create fuzzy spatial inference model functions evaluate ) Fuzzy Spatial Data Handling Module (e.g., fuzzy numerical operations, fuzzy geometric set operations, fuzzy topological predicates) Construction Module (e.g., spa_creator) Basic Module (e.g., S4 classes basic functions)","code":""}]
